* gcc : 여러 운영체제에서 컴파일 가능, 크로스 컴파일(intel architecture -> arm architecture) 가능

* test.c 를 gcc로 컴파일하기

1. 전처리 과정 (test.i)
2. 컴파일 과정 (test.s)
3. 목적코드 생성 과정 (test.o)
4. 링킹 -> 실행 파일

* gcc 컴파일시
-v -save-temps 옵션을 이용하면 과정을 확인할 수 있다.
ex) gcc -v -save-temps -o oslab oslab.c

* gcc 옵션 규칙
-설정 : -[f|W|m][옵션]		ex) -Wunused-variable
-해제 : -[f|W|m]no-[옵션]		ex) -Wnounused-variable
-f : 컴파일러의 특정 기능과 관련된 옵션
-W : 경고와 관련된 옵션
	-Wall (W all) : 모든 모호한 문법에 대해 경고 메시지 출력
		단, -Wcast-qual 과 같은 옵션은 -Wall이 잡지 못하니 주의!
	-W : 합법적이나 모호한 코딩에 대해, 부가적인 정보 제공
-m : 아키텍처 종속적인 옵션

* gcc의 매크로 정의 옵션
-D[매크로]
	#define [매크로]	를 추가한 것과 동일
	gcc - DDEBUG oslab.c -> #define DEBUG를 추가한 것과 동일
-D[매크로] = [매크로 값]
	#define [매크로] [매크로 값]  을 추가한 것과 동일
	gcc -DPI=3.14 oslab.c -> #define PI 3.14를 추가한 것과 동일
-U[매크로]
	#undef [매크로]

즉, 컴파일할 때 포함될 소스를 선택할 수 있다! (상당히 유용...)
ex) DEBUG시 gcc 상에서 -DDEBUG를 추가하면 훨씬 유용하다

* tail -f 파일명
실시간으로 동작하는 파일의 경우, 다른 터미널에서, 실시간으로 추가되는 파일의 내용을 볼 수 있다.

* gcc의 최적화 옵션 - 최적화를 통해 실행시간을 단축시킨다.
-> 과도한 함수 호출 제거
-> 상수의 전달과 변수 복제 전달의 최적화
-> 불필요한 loop 제거
-> 상수의 곱셈 최적화

-O0 : 최적화를 수행하지 않음. 컴파일 시 최적화 옵션을 붙이지 않을 경우 -O0와 같이 동작
	(debug 단계에서 많이 수행)
-O1 : -O 옵션과 동일하며 효과가 큰 몇 가지 기본 최적화를 수행
-O2 : 가장 많이 사용하는 최적화 옵션 (trade-off가 존재하지 않는 거의 모든 최적화를 수행)
	(배포 단계에서 많이 수행)
-O3 : 가장 높은 레벨의 최적화
	(but O2보다 못할 때도 많음, flag가 너무 많아서...)
-Os : 사이즈 최적화
	(정말 작은 기기에서도 사용할 수 있게 최적화해주는 옵션)
	(메모리 사이즈가 커진 현재에는 큰 의미가 없을 수 있음)

* gdb : 디버깅/컴파일 툴 (-g 또는 -ggdb 옵션을 붙임)
ex) gcc -g oslab.c	: 실행 파일에 표준 디버깅 정보 삽입
    gcc -ggdb oslab.c	: 실행 파일에 gdb에서 사용가능한 디버깅 정보 삽입